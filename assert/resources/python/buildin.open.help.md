[Origin-File](/assert/repos/python/buildin.open.help.txt)

Help on built-in function open in module io:

内容来自 `open.__doc__` 对象.

```py
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
# Open file and return a stream.  Raise OSError upon failure.
```

打开文件并返回流. 当打开失败时抛出 `OSError`.

参数 `file` 是字符串类型数据, 可以是普通文本, 也可以是二进制编码的字符串. 给出需要打开的文件名 (如果文件不在当前目录, 需要给出文件的路径, 绝对路径或相对路径.) 或者要 wrap 的文件的整数文件描述符. (如果给出了文件描述符, 则在关闭 I/O 对象时关闭它, 除非设置 `closefd=False`).

参数 `mode` 是一个字符串类型的数据, 用于指定文件的打开方式. 默认为 "r", 意味着文本以只读(text readonly) 模式打开. 其他常见值是 "w" 用于写入 (如果文件已存在则截断), "x" 用于创建和写入新文件, 和 "a" 用于追加 (在某些 Unix 系统上, 意味着所有写入都追加到末尾, 无论当前读写指针在何处.) 在文本模式 "t" 下, 如果未指定编码, 则使用系统编码, 通过调用 `locale.getpreferredencoding(False)` 获取当前语言环境编码. (对于读写原始字节, 使用二进制模式 "b", 此种模式不指定编码). 所有可用的模式有:

```
========= ===============================================================
Character Meaning
--------- ---------------------------------------------------------------
'r'       文本 只读. (默认模式)
'w'       文本 只写, 如果文本已存在则截断文件.
'x'       只创建新文件, 并以写模式打开它.
'a'       以写模式打开, 如果文件存在则在末尾添加
'b'       二进制模式
't'       文本模式
'+'       打开文件以更新 (读写)
'U'       universal newline mode (已弃用)
========= ===============================================================
```

默认的模式是 "rt" (以读文本模式打开). 对任意的二进制访问, "w+b" 模式将会截断文件为 0 字节打开, 而 "r+b" 则不会截断. "x" 模式意味着 "w", 但如果文件已存在则抛出 `FileExistsError` 而不会截断文件, 当然也不会打开.

Python 区分以二进制模式和文本模式打开的文件, 即使底层操作系统不区分. 以二进制模式打开(将 `b` 添加到 `mode` 参数)的文件返回内容为字节对象, 没有进行任何解码. 在文本模式(默认, 或者将 `t` 添加到 `mode` 参数), 文件的内容作为字符串返回, 首先使用依赖于系统平台的编码, 或使用 `encoding` 参数指定编码(如果有的话).

"U" 模式已启用, 将在未来版本中引发异常. 它在 Python3 版本中不会生效. 使用 `newline` 参数来控制通用换行模式.

参数 `buffering` 是一个可选的整数, 用来设置缓冲策略. 

- `0` 关闭缓冲. (仅允许二进制模式下使用)
- `1` 选择行缓冲. (仅允许文本模式下使用)
- `值>1` 表示固定大小的块缓冲区大小.

没有给定缓冲参数时, 默认的缓冲策略如下:

- 二进制文件以固定大小的块进行缓冲; 使用启发式方法选择缓冲区大小, 驶入确定底层设备的 "块大小" 并回调到 `io.DEFAULT_BUFFER_SIZE`. 在许多系统上, 缓冲区长度为 4096 或 8192 字节.

- "交互式" 文本文件, (调用 `isatty()` 方法, 返回 `True` 的文件. "is a tty") 使用行缓冲. 其他文本文件缓冲策略同二进制文件.

参数 `encoding` 指定解码或编码文件使用的字符编码. 它只应用于文本模式. 默认编码取决于系统平台, 但可以向 Python 传递任何支持编码. 参阅 `codecs` 模块文档获取支持编码格式列表.

参数 `errors` 是一个可选的字符串, 用于指定如何处理编码错误---此参数不应用于二进制模式. 各值对应的策略:

- 默认值 "none", 如果存在编码错误则抛出 `ValueError` 异常. (同 "strict")
- "strict", 如果存在编码错误则抛出 `ValueError` 异常.
- "ignore", 忽略错误. (注意, 忽略编码错误可能导致数据丢失.)

参阅 `codecs.register` 模块文档或运行 `help(codecs.Codec)` 获取有效的编码错误字符串列表.

参数 `newline` 控制通用换行工作方式(仅应用于文本模式). 仅接受 `None`, `""` (空), "\n"(换行符, Unix, 推荐), "\r\n"(回车换行, MS-DOS). 工作方式如下:

输入(读取)时:

- 如果 `newline` 的值为 `None`, 通用换行模式被启用. 输入的各行可以以 "\n", "\r" 或 "\r\n" 结尾, 并且它们在被返回给函数调用前将被翻译成 "\n".
- 如果值为 `""`, 则通用换行模式被启用, 但输入的换行符不会被翻译. 
- 如果为其他合法的值, 输入的各行将会以规定字符结尾, 且换行符不会被翻译. (就是说以 `newline` 参数规定的字符作为换行符, 识别一行字符串)

输出(写入)时:

- 如果 `newline` 的值为 `None`, 任何 `"\n"` 换行符将被翻译为系统默认换行符(即 `os.linesep`).
- 如果 `newline` 的值是 `""` 或 `"\n"`, 输出时不会翻译换行符.
- 如果为其他合法的值, 任何 `"\n"` 都会被翻译为指定字符.

**注**: Python 在处理文本时, 内部使用 `\n` 作为换行符.

如果参数 `closefd` 的值为 `False`, 则在关闭文件后, 基础文件描述符将保持打开状态. 这在给出文件名时不起作用, 在此情况下必须为 `True`.

可以通过传递可调用的 `*opener*` 来使用自定义的 opener. 通过使用 `(*file*, *flags*)` 调用 `*opener*` 获取文件对象的基础文件描述符. `*opener*` 必须返回一个打开的文件描述符(将 `os.open` 传递给 `*opener*` 会产生类似于传递 `None` 的功能).

`open()` 返回一个文件对象, 类型取决于 `mode`, 并且通过它执行标准文件操作例如读写. 当 `open()` 用于以文本模式打开文件(例如 `r`, `wt`, `rt` 等), 它将会返回一个 `TextIOWrapper`. 当以二进制模式打开文件, 返回的类会有所不同: 在 `rb` 模式, 返回 `BufferedReader`; 在 `wb` 和 `ab` 模式, 返回 `BufferedWriter`, 在 `+b` 模式, 返回 `BufferedRandom`.

也可以使用字符串或字节数组作为读取和写入的文件. 对于字符串, `StringIO` 可以像在文本模式下打开的文件一样使用; 对于字节, `BytesIO` 可以像在二进制模式下打开的文件一样使用.
