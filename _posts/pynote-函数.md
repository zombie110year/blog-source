---
title: '[PyNote]-函数'
mathjax: false
tags:
  - Python
  - Note
categories:
  - Python
date: 2018-08-13 00:35:59
---

# 语法

```py
def function_name(args):
    pass
```

别忘了冒号与缩进!

# 参数

## 设置形式参数

定义函数时需要向函数设定形式参数.

设置形参列表有以下格式:

- 一般参数
- 默认参数
- 可变参数

以下是例子:

```py
def func(a, b, c=12, *args, **kwargs):
    pass
```

以上的 `a` , `b` 就是一般参数, `c=12` 就是一个有默认值的参数, 而 `*args` 和 `**kwargs` 则是可变参数.

## 传递实际参数

向函数传递参数的时候, 有位置参数和关键词参数的形式.

- 位置参数, 是指在传递实际参数的时候, 没有给出参数名, 而只在参数列表的相应位置放置了参数的值. 在使用位置参数传参的时候, 值与参数在形参列表中处于的位置必须一一对应.
- 关键词参数, 是指在传递实际参数的时候, 采用了 `name=value` 的形式. 此种传参办法将会把值传递给对应命名的参数. 并且实参列表与形参列表不需要在位置上一一对应.
- **如果混用两种传参办法, 则必须有 "位置参数在列表最前, 关键词参数在列表最后" 的关系. 并且, 由于位置参数传值与形式参数所处位置严格对应, 如果企图在前方使用位置参数将值传递给了某靠后形参, 后方又企图用关键词参数给靠前参数传参, 则会发生位置参数按位置将值传递给 a, 关键词参数又将值再次传递给 a, 而另一个原计划按位置传参的参数 b 则无法接收到值**. 以下是一个例子:

```py
def func(a, b, c, d):
    pass

func(1, 3, b=2, d=4)
# 原以为 func(a=1, c=3, b=2, d=4)
# 实际上 func(a=1, b=3, b=2, d=4)       # 于是 c=none
```

- 可变参数会把前面未给定名称的参数储存起来, `*args` 将会就以元组的形式存储所有多余的按位置传参的参数. `**kwargs` 则会以字典的形式存储关键词参数. `*args` 和 `**kwargs` 可以改成其他名称.
  - 可变参数必须在整个传参列表的最后方, 并且其内部也必须有 "位置参数在列表最前, 关键词参数在列表最后" 的关系.

例如:

```py
def func(*args, **kwargs):
        print(item, kwargs, sep='\n')

func(1,2,3,4,a=5,b=6,c=7)
# 运行结果
(1, 2, 3, 4)
{'a': 5, 'b': 6, 'c': 7}
```

# 返回值

函数可以返回任意对象, 因为 "Python 中任意对象都是由 命名->对象 的指针" (暂时不能理解). 函数的返回值, 就是返回命名. 如果将其赋值给另一个变量, 就相当于多了一个指向同一对象的指针.

```py
i = [1, 2, 3, 4]
j = i
print("i=\n", i, "j=\n", j, sep='\n')
i.append("Hello")
print("i=\n", i, "j=\n", j, sep='\n')
# 输出, 可以发现, 只修改了 i, 却也影响到了 j, 说明它们实际上是同一个对象.
i=[1, 2, 3, 4]
j=[1, 2, 3, 4]
i=[1, 2, 3, 4, 'Hello']
j=[1, 2, 3, 4, 'Hello']
```

但是对于函数的返回值, 如果返回的不是一个全局变量话, 在函数结束之后变量就被删除. 只留下值被赋值给另一变量.

## 返回一个元组

可以通过 `return x,y,z` 返回逗号表达式的语句返回一个元组 `(x,y,z)`. 并且也可以用一个逗号表达式去接收它:

```py
>>> def example(a,b):
>>>     return b,a
>>> x,y = example(1,2)
>>> print(x,y)
2 1
```

## 语法

```py
def func():
    return Something
```

# 变量的作用域

```
Build-in (内建作用域)
        Global (全局作用域)
            Enclosing (闭包作用域)
                Local (本地作用域)

在处理变量时, 会按照 Local->Enclosing->Global->Build-in 的顺序查找.
```

Python 中 `定义函数`, `定义类` 会造成作用域的分级. 也就是说函数与类中的变量是处于本地作用域中的. 而其他控制结构并不会发生作用域的分级.

- 内建作用域: 一个小常数对象(如 `True`, `False`, `None`, 以及 `0~255`返回的整数)会处于内建作用域中, 永远不会消失.
- 全局作用域: 作用于本程序全局, 如果要在函数内部改变它的值, 需要提前用 `global` 关键词声明.
- 闭包作用域: TODO: 函数闭包?!
- 本地作用域: 只存在于该次函数调用, 函数调用完毕便被清除.

# 方法

有时候, 会听到 方法 `Method` 这个词汇, "方法" 是指定义在 类 `class` 中, 对一个类的 "实例" 起作用的函数. 方法和函数没有本质上的区别, 只是在参数传递上有所不同.

函数以此形式传参:

```py
function(arg1, arg2, ...)
```

而方法则可以如此传参:

```py
instance.method(arg2, arg3, ...)
# 或者用一般函数的形式:
ClassName.method(instance, arg2, arg3, ...)
```

具体描述见 [PyNote-类#方法](/2018/08/pynote-类#方法)

# lambda 表达式

`lambda` 表达式的语法为

```py
lambda 参数:返回值
```

`lambda` 表达式用于构建简短的函数, 例如:

```py
>>> add = lambda x,y:x+y
>>> add(1,2)
3
```

`lambda` 返回值中的变量可以是外部变量, 并且根据程序 **当前** 的运行情况赋值. 例如:

```py
>>> add = lambda y:x+y
>>> x = 10
>>> add(10)
20
>>> x = 20
>>> add(20)
40
```
